"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cloudwatch = require("@aws-cdk/aws-cloudwatch");
const cdk = require("@aws-cdk/cdk");
const base_service_1 = require("../base/base-service");
const task_definition_1 = require("../base/task-definition");
const util_1 = require("../util");
/**
 * Start a service on an ECS cluster
 */
class Ec2Service extends base_service_1.BaseService {
    constructor(scope, id, props) {
        if (props.daemon && props.desiredCount !== undefined) {
            throw new Error('Daemon mode launches one task on every instance. Don\'t supply desiredCount.');
        }
        if (!util_1.isEc2Compatible(props.taskDefinition.compatibility)) {
            throw new Error('Supplied TaskDefinition is not configured for compatibility with EC2');
        }
        super(scope, id, Object.assign({}, props, { 
            // If daemon, desiredCount must be undefined and that's what we want. Otherwise, default to 1.
            desiredCount: props.daemon || props.desiredCount !== undefined ? props.desiredCount : 1 }), {
            cluster: props.cluster.clusterName,
            taskDefinition: props.taskDefinition.taskDefinitionArn,
            launchType: 'EC2',
            placementConstraints: new cdk.Token(() => this.constraints),
            placementStrategies: new cdk.Token(() => this.strategies),
            schedulingStrategy: props.daemon ? 'DAEMON' : 'REPLICA',
        }, props.cluster.clusterName, props.taskDefinition);
        this.clusterName = props.cluster.clusterName;
        this.constraints = [];
        this.strategies = [];
        this.daemon = props.daemon || false;
        if (props.taskDefinition.networkMode === task_definition_1.NetworkMode.AwsVpc) {
            this.configureAwsVpcNetworking(props.cluster.vpc, false, props.vpcSubnets, props.securityGroup);
        }
        else {
            // Either None, Bridge or Host networking. Copy SecurityGroup from ASG.
            validateNoNetworkingProps(props);
            this.connections.addSecurityGroup(...props.cluster.connections.securityGroups);
        }
        if (props.placeOnDistinctInstances) {
            this.constraints.push({ type: 'distinctInstance' });
        }
        if (!this.taskDefinition.defaultContainer) {
            throw new Error('A TaskDefinition must have at least one essential container');
        }
    }
    /**
     * Place services only on instances matching the given query expression
     *
     * You can specify multiple expressions in one call. The tasks will only
     * be placed on instances matching all expressions.
     *
     * @see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html
     */
    placeOnMemberOf(...expressions) {
        for (const expression of expressions) {
            this.constraints.push({ type: 'memberOf', expression });
        }
    }
    /**
     * Try to place tasks spread across instance attributes.
     *
     * You can use one of the built-in attributes found on `BuiltInAttributes`
     * or supply your own custom instance attributes. If more than one attribute
     * is supplied, spreading is done in order.
     *
     * @default attributes instanceId
     */
    placeSpreadAcross(...fields) {
        if (this.daemon) {
            throw new Error("Can't configure spreading placement for a service with daemon=true");
        }
        if (fields.length === 0) {
            fields = [BuiltInAttributes.InstanceId];
        }
        for (const field of fields) {
            this.strategies.push({ type: 'spread', field });
        }
    }
    /**
     * Try to place tasks on instances with the least amount of indicated resource available
     *
     * This ensures the total consumption of this resource is lowest.
     */
    placePackedBy(resource) {
        if (this.daemon) {
            throw new Error("Can't configure packing placement for a service with daemon=true");
        }
        this.strategies.push({ type: 'binpack', field: resource });
    }
    /**
     * Place tasks randomly across the available instances.
     */
    placeRandomly() {
        if (this.daemon) {
            throw new Error("Can't configure random placement for a service with daemon=true");
        }
        this.strategies.push({ type: 'random' });
    }
    /**
     * Register this service as the target of a Classic Load Balancer
     *
     * Don't call this. Call `loadBalancer.addTarget()` instead.
     */
    attachToClassicLB(loadBalancer) {
        if (this.taskDefinition.networkMode === task_definition_1.NetworkMode.Bridge) {
            throw new Error("Cannot use a Classic Load Balancer if NetworkMode is Bridge. Use Host or AwsVpc instead.");
        }
        if (this.taskDefinition.networkMode === task_definition_1.NetworkMode.None) {
            throw new Error("Cannot use a load balancer if NetworkMode is None. Use Host or AwsVpc instead.");
        }
        this.loadBalancers.push({
            loadBalancerName: loadBalancer.loadBalancerName,
            containerName: this.taskDefinition.defaultContainer.node.id,
            containerPort: this.taskDefinition.defaultContainer.containerPort,
        });
    }
    /**
     * Return the given named metric for this Service
     */
    metric(metricName, props) {
        return new cloudwatch.Metric(Object.assign({ namespace: 'AWS/ECS', metricName, dimensions: { ClusterName: this.clusterName, ServiceName: this.serviceName } }, props));
    }
    /**
     * Metric for cluster Memory utilization
     *
     * @default average over 5 minutes
     */
    metricMemoryUtilization(props) {
        return this.metric('MemoryUtilization', props);
    }
    /**
     * Metric for cluster CPU utilization
     *
     * @default average over 5 minutes
     */
    metricCpuUtilization(props) {
        return this.metric('CPUUtilization', props);
    }
    /**
     * Validate this Ec2Service
     */
    validate() {
        const ret = super.validate();
        if (!this.cluster.hasEc2Capacity) {
            ret.push('Cluster for this service needs Ec2 capacity. Call addXxxCapacity() on the cluster.');
        }
        return ret;
    }
}
exports.Ec2Service = Ec2Service;
/**
 * Validate combinations of networking arguments
 */
function validateNoNetworkingProps(props) {
    if (props.vpcSubnets !== undefined || props.securityGroup !== undefined) {
        throw new Error('vpcSubnets and securityGroup can only be used in AwsVpc networking mode');
    }
}
/**
 * Built-in container instance attributes
 */
class BuiltInAttributes {
}
/**
 * The Instance ID of the instance
 */
BuiltInAttributes.InstanceId = 'instanceId';
/**
 * The AZ where the instance is running
 */
BuiltInAttributes.AvailabilityZone = 'attribute:ecs.availability-zone';
/**
 * The AMI ID of the instance
 */
BuiltInAttributes.AmiId = 'attribute:ecs.ami-id';
/**
 * The instance type
 */
BuiltInAttributes.InstanceType = 'attribute:ecs.instance-type';
/**
 * The OS type
 *
 * Either 'linux' or 'windows'.
 */
BuiltInAttributes.OsType = 'attribute:ecs.os-type';
exports.BuiltInAttributes = BuiltInAttributes;
/**
 * Instance resource used for bin packing
 */
var BinPackResource;
(function (BinPackResource) {
    /**
     * Fill up hosts' CPU allocations first
     */
    BinPackResource["Cpu"] = "cpu";
    /**
     * Fill up hosts' memory allocations first
     */
    BinPackResource["Memory"] = "memory";
})(BinPackResource = exports.BinPackResource || (exports.BinPackResource = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWMyLXNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJlYzItc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHNEQUF3RDtBQUd4RCxvQ0FBcUM7QUFDckMsdURBQXFFO0FBQ3JFLDZEQUFzRTtBQUV0RSxrQ0FBMEM7QUErQzFDOztHQUVHO0FBQ0gsTUFBYSxVQUFXLFNBQVEsMEJBQVc7SUFVekMsWUFBWSxLQUFvQixFQUFFLEVBQVUsRUFBRSxLQUFzQjtRQUNsRSxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUU7WUFDcEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw4RUFBOEUsQ0FBQyxDQUFDO1NBQ2pHO1FBRUQsSUFBSSxDQUFDLHNCQUFlLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUN4RCxNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7UUFFRCxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsb0JBQ1YsS0FBSztZQUNSLDhGQUE4RjtZQUM5RixZQUFZLEVBQUUsS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUV6RjtZQUNFLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVc7WUFDbEMsY0FBYyxFQUFFLEtBQUssQ0FBQyxjQUFjLENBQUMsaUJBQWlCO1lBQ3RELFVBQVUsRUFBRSxLQUFLO1lBQ2pCLG9CQUFvQixFQUFFLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQzNELG1CQUFtQixFQUFFLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lB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O1FBQ2hCLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUU7WUFDaEMsR0FBRyxDQUFDLElBQUksQ0FBQyxvRkFBb0YsQ0FBQyxDQUFDO1NBQ2hHO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0NBQ0Y7QUEvS0QsZ0NBK0tDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLHlCQUF5QixDQUFDLEtBQXNCO0lBQ3ZELElBQUksS0FBSyxDQUFDLFVBQVUsS0FBSyxTQUFTLElBQUksS0FBSyxDQUFDLGFBQWEsS0FBSyxTQUFTLEVBQUU7UUFDdkUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5RUFBeUUsQ0FBQyxDQUFDO0tBQzVGO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxpQkFBaUI7O0FBQzVCOztHQUVHO0FBQ29CLDRCQUFVLEdBQUcsWUFBWSxDQUFDO0FBRWpEOztHQUVHO0FBQ29CLGtDQUFnQixHQUFHLGlDQUFpQyxDQUFDO0FBRTVFOztHQUVHO0FBQ29CLHVCQUFLLEdBQUcsc0JBQXNCLENBQUM7QUFFdEQ7O0dBRUc7QUFDb0IsOEJBQVksR0FBRyw2QkFBNkIsQ0FBQztBQUVwRTs7OztHQUlHO0FBQ29CLHdCQUFNLEdBQUcsdUJBQXVCLENBQUM7QUExQjFELDhDQTJCQztBQUVEOztHQUVHO0FBQ0gsSUFBWSxlQVVYO0FBVkQsV0FBWSxlQUFlO0lBQ3pCOztPQUVHO0lBQ0gsOEJBQVcsQ0FBQTtJQUVYOztPQUVHO0lBQ0gsb0NBQWlCLENBQUE7QUFDbkIsQ0FBQyxFQVZXLGVBQWUsR0FBZix1QkFBZSxLQUFmLHVCQUFlLFFBVTFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNsb3Vkd2F0Y2ggPSByZXF1aXJlICgnQGF3cy1jZGsvYXdzLWNsb3Vkd2F0Y2gnKTtcbmltcG9ydCBlYzIgPSByZXF1aXJlKCdAYXdzLWNkay9hd3MtZWMyJyk7XG5pbXBvcnQgZWxiID0gcmVxdWlyZSgnQGF3cy1jZGsvYXdzLWVsYXN0aWNsb2FkYmFsYW5jaW5nJyk7XG5pbXBvcnQgY2RrID0gcmVxdWlyZSgnQGF3cy1jZGsvY2RrJyk7XG5pbXBvcnQgeyBCYXNlU2VydmljZSwgQmFzZVNlcnZpY2VQcm9wcyB9IGZyb20gJy4uL2Jhc2UvYmFzZS1zZXJ2aWNlJztcbmltcG9ydCB7IE5ldHdvcmtNb2RlLCBUYXNrRGVmaW5pdGlvbiB9IGZyb20gJy4uL2Jhc2UvdGFzay1kZWZpbml0aW9uJztcbmltcG9ydCB7IENmblNlcnZpY2UgfSBmcm9tICcuLi9lY3MuZ2VuZXJhdGVkJztcbmltcG9ydCB7IGlzRWMyQ29tcGF0aWJsZSB9IGZyb20gJy4uL3V0aWwnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgdG8gZGVmaW5lIGFuIEVDUyBzZXJ2aWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWMyU2VydmljZVByb3BzIGV4dGVuZHMgQmFzZVNlcnZpY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBUYXNrIERlZmluaXRpb24gdXNlZCBmb3IgcnVubmluZyB0YXNrcyBpbiB0aGUgc2VydmljZVxuICAgKi9cbiAgcmVhZG9ubHkgdGFza0RlZmluaXRpb246IFRhc2tEZWZpbml0aW9uO1xuXG4gIC8qKlxuICAgKiBJbiB3aGF0IHN1Ym5ldHMgdG8gcGxhY2UgdGhlIHRhc2sncyBFTklzXG4gICAqXG4gICAqIChPbmx5IGFwcGxpY2FibGUgaW4gY2FzZSB0aGUgVGFza0RlZmluaXRpb24gaXMgY29uZmlndXJlZCBmb3IgQXdzVnBjIG5ldHdvcmtpbmcpXG4gICAqXG4gICAqIEBkZWZhdWx0IFByaXZhdGUgc3VibmV0c1xuICAgKi9cbiAgcmVhZG9ubHkgdnBjU3VibmV0cz86IGVjMi5TdWJuZXRTZWxlY3Rpb247XG5cbiAgLyoqXG4gICAqIEV4aXN0aW5nIHNlY3VyaXR5IGdyb3VwIHRvIHVzZSBmb3IgdGhlIHRhc2sncyBFTklzXG4gICAqXG4gICAqIChPbmx5IGFwcGxpY2FibGUgaW4gY2FzZSB0aGUgVGFza0RlZmluaXRpb24gaXMgY29uZmlndXJlZCBmb3IgQXdzVnBjIG5ldHdvcmtpbmcpXG4gICAqXG4gICAqIEBkZWZhdWx0IEEgbmV3IHNlY3VyaXR5IGdyb3VwIGlzIGNyZWF0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHNlY3VyaXR5R3JvdXA/OiBlYzIuSVNlY3VyaXR5R3JvdXA7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RhcnQgc2VydmljZXMgb24gZGlzdGluY3QgaW5zdGFuY2VzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHBsYWNlT25EaXN0aW5jdEluc3RhbmNlcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERlcGxveSBleGFjdGx5IG9uZSB0YXNrIG9uIGVhY2ggaW5zdGFuY2UgaW4geW91ciBjbHVzdGVyLlxuICAgKlxuICAgKiBXaGVuIHVzaW5nIHRoaXMgc3RyYXRlZ3ksIGRvIG5vdCBzcGVjaWZ5IGEgZGVzaXJlZCBudW1iZXIgb2YgdGFza3Mgb3IgYW55XG4gICAqIHRhc2sgcGxhY2VtZW50IHN0cmF0ZWdpZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBkYWVtb24/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFN0YXJ0IGEgc2VydmljZSBvbiBhbiBFQ1MgY2x1c3RlclxuICovXG5leHBvcnQgY2xhc3MgRWMyU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIGltcGxlbWVudHMgZWxiLklMb2FkQmFsYW5jZXJUYXJnZXQge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNsdXN0ZXJOYW1lOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBjb25zdHJhaW50czogQ2ZuU2VydmljZS5QbGFjZW1lbnRDb25zdHJhaW50UHJvcGVydHlbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBzdHJhdGVnaWVzOiBDZm5TZXJ2aWNlLlBsYWNlbWVudFN0cmF0ZWd5UHJvcGVydHlbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBkYWVtb246IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IGNkay5Db25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBFYzJTZXJ2aWNlUHJvcHMpIHtcbiAgICBpZiAocHJvcHMuZGFlbW9uICYmIHByb3BzLmRlc2lyZWRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhZW1vbiBtb2RlIGxhdW5jaGVzIG9uZSB0YXNrIG9uIGV2ZXJ5IGluc3RhbmNlLiBEb25cXCd0IHN1cHBseSBkZXNpcmVkQ291bnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0VjMkNvbXBhdGlibGUocHJvcHMudGFza0RlZmluaXRpb24uY29tcGF0aWJpbGl0eSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgVGFza0RlZmluaXRpb24gaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBFQzInKTtcbiAgICB9XG5cbiAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgLy8gSWYgZGFlbW9uLCBkZXNpcmVkQ291bnQgbXVzdCBiZSB1bmRlZmluZWQgYW5kIHRoYXQncyB3aGF0IHdlIHdhbnQuIE90aGVyd2lzZSwgZGVmYXVsdCB0byAxLlxuICAgICAgZGVzaXJlZENvdW50OiBwcm9wcy5kYWVtb24gfHwgcHJvcHMuZGVzaXJlZENvdW50ICE9PSB1bmRlZmluZWQgPyBwcm9wcy5kZXNpcmVkQ291bnQgOiAxLFxuICAgIH0sXG4gICAge1xuICAgICAgY2x1c3RlcjogcHJvcHMuY2x1c3Rlci5jbHVzdGVyTmFtZSxcbiAgICAgIHRhc2tEZWZpbml0aW9uOiBwcm9wcy50YXNrRGVmaW5pdGlvbi50YXNrRGVmaW5pdGlvbkFybixcbiAgICAgIGxhdW5jaFR5cGU6ICdFQzInLFxuICAgICAgcGxhY2VtZW50Q29uc3RyYWludHM6IG5ldyBjZGsuVG9rZW4oKCkgPT4gdGhpcy5jb25zdHJhaW50cyksXG4gICAgICBwbGFjZW1lbnRTdHJhdGVnaWVzOiBuZXcgY2RrLlRva2VuKCgpID0+IHRoaXMuc3RyYXRlZ2llcyksXG4gICAgICBzY2hlZHVsaW5nU3RyYXRlZ3k6IHByb3BzLmRhZW1vbiA/ICdEQUVNT04nIDogJ1JFUExJQ0EnLFxuICAgIH0sIHByb3BzLmNsdXN0ZXIuY2x1c3Rlck5hbWUsIHByb3BzLnRhc2tEZWZpbml0aW9uKTtcblxuICAgIHRoaXMuY2x1c3Rlck5hbWUgPSBwcm9wcy5jbHVzdGVyLmNsdXN0ZXJOYW1lO1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcbiAgICB0aGlzLnN0cmF0ZWdpZXMgPSBbXTtcbiAgICB0aGlzLmRhZW1vbiA9IHByb3BzLmRhZW1vbiB8fCBmYWxzZTtcblxuICAgIGlmIChwcm9wcy50YXNrRGVmaW5pdGlvbi5uZXR3b3JrTW9kZSA9PT0gTmV0d29ya01vZGUuQXdzVnBjKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyZUF3c1ZwY05ldHdvcmtpbmcocHJvcHMuY2x1c3Rlci52cGMsIGZhbHNlLCBwcm9wcy52cGNTdWJuZXRzLCBwcm9wcy5zZWN1cml0eUdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIE5vbmUsIEJyaWRnZSBvciBIb3N0IG5ldHdvcmtpbmcuIENvcHkgU2VjdXJpdHlHcm91cCBmcm9tIEFTRy5cbiAgICAgIHZhbGlkYXRlTm9OZXR3b3JraW5nUHJvcHMocHJvcHMpO1xuICAgICAgdGhpcy5jb25uZWN0aW9ucy5hZGRTZWN1cml0eUdyb3VwKC4uLnByb3BzLmNsdXN0ZXIuY29ubmVjdGlvbnMuc2VjdXJpdHlHcm91cHMpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5wbGFjZU9uRGlzdGluY3RJbnN0YW5jZXMpIHtcbiAgICAgIHRoaXMuY29uc3RyYWludHMucHVzaCh7IHR5cGU6ICdkaXN0aW5jdEluc3RhbmNlJyB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudGFza0RlZmluaXRpb24uZGVmYXVsdENvbnRhaW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIFRhc2tEZWZpbml0aW9uIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZXNzZW50aWFsIGNvbnRhaW5lcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQbGFjZSBzZXJ2aWNlcyBvbmx5IG9uIGluc3RhbmNlcyBtYXRjaGluZyB0aGUgZ2l2ZW4gcXVlcnkgZXhwcmVzc2lvblxuICAgKlxuICAgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgZXhwcmVzc2lvbnMgaW4gb25lIGNhbGwuIFRoZSB0YXNrcyB3aWxsIG9ubHlcbiAgICogYmUgcGxhY2VkIG9uIGluc3RhbmNlcyBtYXRjaGluZyBhbGwgZXhwcmVzc2lvbnMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkVDUy9sYXRlc3QvZGV2ZWxvcGVyZ3VpZGUvY2x1c3Rlci1xdWVyeS1sYW5ndWFnZS5odG1sXG4gICAqL1xuICBwdWJsaWMgcGxhY2VPbk1lbWJlck9mKC4uLmV4cHJlc3Npb25zOiBzdHJpbmdbXSkge1xuICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBleHByZXNzaW9ucykge1xuICAgICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKHsgdHlwZTogJ21lbWJlck9mJywgZXhwcmVzc2lvbiB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIHBsYWNlIHRhc2tzIHNwcmVhZCBhY3Jvc3MgaW5zdGFuY2UgYXR0cmlidXRlcy5cbiAgICpcbiAgICogWW91IGNhbiB1c2Ugb25lIG9mIHRoZSBidWlsdC1pbiBhdHRyaWJ1dGVzIGZvdW5kIG9uIGBCdWlsdEluQXR0cmlidXRlc2BcbiAgICogb3Igc3VwcGx5IHlvdXIgb3duIGN1c3RvbSBpbnN0YW5jZSBhdHRyaWJ1dGVzLiBJZiBtb3JlIHRoYW4gb25lIGF0dHJpYnV0ZVxuICAgKiBpcyBzdXBwbGllZCwgc3ByZWFkaW5nIGlzIGRvbmUgaW4gb3JkZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IGF0dHJpYnV0ZXMgaW5zdGFuY2VJZFxuICAgKi9cbiAgcHVibGljIHBsYWNlU3ByZWFkQWNyb3NzKC4uLmZpZWxkczogc3RyaW5nW10pIHtcbiAgICBpZiAodGhpcy5kYWVtb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbmZpZ3VyZSBzcHJlYWRpbmcgcGxhY2VtZW50IGZvciBhIHNlcnZpY2Ugd2l0aCBkYWVtb249dHJ1ZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZmllbGRzID0gW0J1aWx0SW5BdHRyaWJ1dGVzLkluc3RhbmNlSWRdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgdGhpcy5zdHJhdGVnaWVzLnB1c2goeyB0eXBlOiAnc3ByZWFkJywgZmllbGQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBwbGFjZSB0YXNrcyBvbiBpbnN0YW5jZXMgd2l0aCB0aGUgbGVhc3QgYW1vdW50IG9mIGluZGljYXRlZCByZXNvdXJjZSBhdmFpbGFibGVcbiAgICpcbiAgICogVGhpcyBlbnN1cmVzIHRoZSB0b3RhbCBjb25zdW1wdGlvbiBvZiB0aGlzIHJlc291cmNlIGlzIGxvd2VzdC5cbiAgICovXG4gIHB1YmxpYyBwbGFjZVBhY2tlZEJ5KHJlc291cmNlOiBCaW5QYWNrUmVzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5kYWVtb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbmZpZ3VyZSBwYWNraW5nIHBsYWNlbWVudCBmb3IgYSBzZXJ2aWNlIHdpdGggZGFlbW9uPXRydWVcIik7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJhdGVnaWVzLnB1c2goeyB0eXBlOiAnYmlucGFjaycsIGZpZWxkOiByZXNvdXJjZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQbGFjZSB0YXNrcyByYW5kb21seSBhY3Jvc3MgdGhlIGF2YWlsYWJsZSBpbnN0YW5jZXMuXG4gICAqL1xuICBwdWJsaWMgcGxhY2VSYW5kb21seSgpIHtcbiAgICBpZiAodGhpcy5kYWVtb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbmZpZ3VyZSByYW5kb20gcGxhY2VtZW50IGZvciBhIHNlcnZpY2Ugd2l0aCBkYWVtb249dHJ1ZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cmF0ZWdpZXMucHVzaCh7IHR5cGU6ICdyYW5kb20nIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRoaXMgc2VydmljZSBhcyB0aGUgdGFyZ2V0IG9mIGEgQ2xhc3NpYyBMb2FkIEJhbGFuY2VyXG4gICAqXG4gICAqIERvbid0IGNhbGwgdGhpcy4gQ2FsbCBgbG9hZEJhbGFuY2VyLmFkZFRhcmdldCgpYCBpbnN0ZWFkLlxuICAgKi9cbiAgcHVibGljIGF0dGFjaFRvQ2xhc3NpY0xCKGxvYWRCYWxhbmNlcjogZWxiLkxvYWRCYWxhbmNlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnRhc2tEZWZpbml0aW9uLm5ldHdvcmtNb2RlID09PSBOZXR3b3JrTW9kZS5CcmlkZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYSBDbGFzc2ljIExvYWQgQmFsYW5jZXIgaWYgTmV0d29ya01vZGUgaXMgQnJpZGdlLiBVc2UgSG9zdCBvciBBd3NWcGMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhc2tEZWZpbml0aW9uLm5ldHdvcmtNb2RlID09PSBOZXR3b3JrTW9kZS5Ob25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGEgbG9hZCBiYWxhbmNlciBpZiBOZXR3b3JrTW9kZSBpcyBOb25lLiBVc2UgSG9zdCBvciBBd3NWcGMgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkQmFsYW5jZXJzLnB1c2goe1xuICAgICAgbG9hZEJhbGFuY2VyTmFtZTogbG9hZEJhbGFuY2VyLmxvYWRCYWxhbmNlck5hbWUsXG4gICAgICBjb250YWluZXJOYW1lOiB0aGlzLnRhc2tEZWZpbml0aW9uLmRlZmF1bHRDb250YWluZXIhLm5vZGUuaWQsXG4gICAgICBjb250YWluZXJQb3J0OiB0aGlzLnRhc2tEZWZpbml0aW9uLmRlZmF1bHRDb250YWluZXIhLmNvbnRhaW5lclBvcnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBnaXZlbiBuYW1lZCBtZXRyaWMgZm9yIHRoaXMgU2VydmljZVxuICAgKi9cbiAgcHVibGljIG1ldHJpYyhtZXRyaWNOYW1lOiBzdHJpbmcsIHByb3BzPzogY2xvdWR3YXRjaC5NZXRyaWNDdXN0b21pemF0aW9uKTogY2xvdWR3YXRjaC5NZXRyaWMge1xuICAgIHJldHVybiBuZXcgY2xvdWR3YXRjaC5NZXRyaWMoe1xuICAgICAgbmFtZXNwYWNlOiAnQVdTL0VDUycsXG4gICAgICBtZXRyaWNOYW1lLFxuICAgICAgZGltZW5zaW9uczogeyBDbHVzdGVyTmFtZTogdGhpcy5jbHVzdGVyTmFtZSwgU2VydmljZU5hbWU6IHRoaXMuc2VydmljZU5hbWUgfSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0cmljIGZvciBjbHVzdGVyIE1lbW9yeSB1dGlsaXphdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCBhdmVyYWdlIG92ZXIgNSBtaW51dGVzXG4gICAqL1xuICBwdWJsaWMgbWV0cmljTWVtb3J5VXRpbGl6YXRpb24ocHJvcHM/OiBjbG91ZHdhdGNoLk1ldHJpY0N1c3RvbWl6YXRpb24pOiBjbG91ZHdhdGNoLk1ldHJpYyB7XG4gICAgcmV0dXJuIHRoaXMubWV0cmljKCdNZW1vcnlVdGlsaXphdGlvbicsIHByb3BzICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0cmljIGZvciBjbHVzdGVyIENQVSB1dGlsaXphdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCBhdmVyYWdlIG92ZXIgNSBtaW51dGVzXG4gICAqL1xuICBwdWJsaWMgbWV0cmljQ3B1VXRpbGl6YXRpb24ocHJvcHM/OiBjbG91ZHdhdGNoLk1ldHJpY0N1c3RvbWl6YXRpb24pOiBjbG91ZHdhdGNoLk1ldHJpYyB7XG4gICAgcmV0dXJuIHRoaXMubWV0cmljKCdDUFVVdGlsaXphdGlvbicsIHByb3BzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGlzIEVjMlNlcnZpY2VcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZSgpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmV0ID0gc3VwZXIudmFsaWRhdGUoKTtcbiAgICBpZiAoIXRoaXMuY2x1c3Rlci5oYXNFYzJDYXBhY2l0eSkge1xuICAgICAgcmV0LnB1c2goJ0NsdXN0ZXIgZm9yIHRoaXMgc2VydmljZSBuZWVkcyBFYzIgY2FwYWNpdHkuIENhbGwgYWRkWHh4Q2FwYWNpdHkoKSBvbiB0aGUgY2x1c3Rlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGNvbWJpbmF0aW9ucyBvZiBuZXR3b3JraW5nIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5vTmV0d29ya2luZ1Byb3BzKHByb3BzOiBFYzJTZXJ2aWNlUHJvcHMpIHtcbiAgaWYgKHByb3BzLnZwY1N1Ym5ldHMgIT09IHVuZGVmaW5lZCB8fCBwcm9wcy5zZWN1cml0eUdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZwY1N1Ym5ldHMgYW5kIHNlY3VyaXR5R3JvdXAgY2FuIG9ubHkgYmUgdXNlZCBpbiBBd3NWcGMgbmV0d29ya2luZyBtb2RlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBCdWlsdC1pbiBjb250YWluZXIgaW5zdGFuY2UgYXR0cmlidXRlc1xuICovXG5leHBvcnQgY2xhc3MgQnVpbHRJbkF0dHJpYnV0ZXMge1xuICAvKipcbiAgICogVGhlIEluc3RhbmNlIElEIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBJbnN0YW5jZUlkID0gJ2luc3RhbmNlSWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgQVogd2hlcmUgdGhlIGluc3RhbmNlIGlzIHJ1bm5pbmdcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQXZhaWxhYmlsaXR5Wm9uZSA9ICdhdHRyaWJ1dGU6ZWNzLmF2YWlsYWJpbGl0eS16b25lJztcblxuICAvKipcbiAgICogVGhlIEFNSSBJRCBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQW1pSWQgPSAnYXR0cmlidXRlOmVjcy5hbWktaWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgdHlwZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBJbnN0YW5jZVR5cGUgPSAnYXR0cmlidXRlOmVjcy5pbnN0YW5jZS10eXBlJztcblxuICAvKipcbiAgICogVGhlIE9TIHR5cGVcbiAgICpcbiAgICogRWl0aGVyICdsaW51eCcgb3IgJ3dpbmRvd3MnLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBPc1R5cGUgPSAnYXR0cmlidXRlOmVjcy5vcy10eXBlJztcbn1cblxuLyoqXG4gKiBJbnN0YW5jZSByZXNvdXJjZSB1c2VkIGZvciBiaW4gcGFja2luZ1xuICovXG5leHBvcnQgZW51bSBCaW5QYWNrUmVzb3VyY2Uge1xuICAvKipcbiAgICogRmlsbCB1cCBob3N0cycgQ1BVIGFsbG9jYXRpb25zIGZpcnN0XG4gICAqL1xuICBDcHUgPSAnY3B1JyxcblxuICAvKipcbiAgICogRmlsbCB1cCBob3N0cycgbWVtb3J5IGFsbG9jYXRpb25zIGZpcnN0XG4gICAqL1xuICBNZW1vcnkgPSAnbWVtb3J5Jyxcbn1cbiJdfQ==
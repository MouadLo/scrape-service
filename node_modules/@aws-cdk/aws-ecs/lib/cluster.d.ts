import autoscaling = require('@aws-cdk/aws-autoscaling');
import cloudwatch = require('@aws-cdk/aws-cloudwatch');
import ec2 = require('@aws-cdk/aws-ec2');
import cloudmap = require('@aws-cdk/aws-servicediscovery');
import cdk = require('@aws-cdk/cdk');
/**
 * Properties to define an ECS cluster
 */
export interface ClusterProps {
    /**
     * A name for the cluster.
     *
     * @default CloudFormation-generated name
     */
    readonly clusterName?: string;
    /**
     * The VPC where your ECS instances will be running or your ENIs will be deployed
     */
    readonly vpc: ec2.IVpcNetwork;
}
/**
 * A container cluster that runs on your EC2 instances
 */
export declare class Cluster extends cdk.Construct implements ICluster {
    /**
     * Import an existing cluster
     */
    static import(scope: cdk.Construct, id: string, props: ClusterImportProps): ICluster;
    /**
     * Connections manager for the EC2 cluster
     */
    readonly connections: ec2.Connections;
    /**
     * The VPC this cluster was created in.
     */
    readonly vpc: ec2.IVpcNetwork;
    /**
     * The ARN of this cluster
     */
    readonly clusterArn: string;
    /**
     * The name of this cluster
     */
    readonly clusterName: string;
    /**
     * The service discovery namespace created in this cluster
     */
    private _defaultNamespace?;
    /**
     * Whether the cluster has EC2 capacity associated with it
     */
    private _hasEc2Capacity;
    constructor(scope: cdk.Construct, id: string, props: ClusterProps);
    /**
     * Add an AWS Cloud Map DNS namespace for this cluster.
     * NOTE: HttpNamespaces are not supported, as ECS always requires a DNSConfig when registering an instance to a Cloud
     * Map service.
     */
    addDefaultCloudMapNamespace(options: NamespaceOptions): cloudmap.INamespace;
    /**
     * Getter for namespace added to cluster
     */
    readonly defaultNamespace: cloudmap.INamespace | undefined;
    /**
     * Add a default-configured AutoScalingGroup running the ECS-optimized AMI to this Cluster
     *
     * Returns the AutoScalingGroup so you can add autoscaling settings to it.
     */
    addCapacity(id: string, options: AddCapacityOptions): autoscaling.AutoScalingGroup;
    /**
     * Add compute capacity to this ECS cluster in the form of an AutoScalingGroup
     */
    addAutoScalingGroup(autoScalingGroup: autoscaling.AutoScalingGroup, options?: AddAutoScalingGroupCapacityOptions): void;
    /**
     * Whether the cluster has EC2 capacity associated with it
     */
    readonly hasEc2Capacity: boolean;
    /**
     * Export the Cluster
     */
    export(): ClusterImportProps;
    /**
     * Metric for cluster CPU reservation
     *
     * @default average over 5 minutes
     */
    metricCpuReservation(props?: cloudwatch.MetricCustomization): cloudwatch.Metric;
    /**
     * Metric for cluster Memory reservation
     *
     * @default average over 5 minutes
     */
    metricMemoryReservation(props?: cloudwatch.MetricCustomization): cloudwatch.Metric;
    /**
     * Return the given named metric for this Cluster
     */
    metric(metricName: string, props?: cloudwatch.MetricCustomization): cloudwatch.Metric;
}
export interface EcsOptimizedAmiProps {
    /**
     * What generation of Amazon Linux to use
     *
     * @default AmazonLinux
     */
    readonly generation?: ec2.AmazonLinuxGeneration;
}
/**
 * Construct a Linux machine image from the latest ECS Optimized AMI published in SSM
 */
export declare class EcsOptimizedAmi implements ec2.IMachineImageSource {
    private readonly generation;
    private readonly amiParameterName;
    constructor(props?: EcsOptimizedAmiProps);
    /**
     * Return the correct image
     */
    getImage(scope: cdk.Construct): ec2.MachineImage;
}
/**
 * An ECS cluster
 */
export interface ICluster extends cdk.IConstruct {
    /**
     * Name of the cluster
     */
    readonly clusterName: string;
    /**
     * The ARN of this cluster
     */
    readonly clusterArn: string;
    /**
     * VPC that the cluster instances are running in
     */
    readonly vpc: ec2.IVpcNetwork;
    /**
     * Connections manager of the cluster instances
     */
    readonly connections: ec2.Connections;
    /**
     * Whether the cluster has EC2 capacity associated with it
     */
    readonly hasEc2Capacity: boolean;
    /**
     * Getter for Cloudmap namespace created in the cluster
     */
    readonly defaultNamespace?: cloudmap.INamespace;
    /**
     * Export the Cluster
     */
    export(): ClusterImportProps;
}
/**
 * Properties to import an ECS cluster
 */
export interface ClusterImportProps {
    /**
     * Name of the cluster
     */
    readonly clusterName: string;
    /**
     * ARN of the cluster
     *
     * @default Derived from clusterName
     */
    readonly clusterArn?: string;
    /**
     * VPC that the cluster instances are running in
     */
    readonly vpc: ec2.VpcNetworkImportProps;
    /**
     * Security group of the cluster instances
     */
    readonly securityGroups: ec2.SecurityGroupImportProps[];
    /**
     * Whether the given cluster has EC2 capacity
     *
     * @default true
     */
    readonly hasEc2Capacity?: boolean;
    /**
     * Default namespace properties
     *
     * @default - No default namespace
     */
    readonly defaultNamespace?: cloudmap.NamespaceImportProps;
}
/**
 * Properties for adding an autoScalingGroup
 */
export interface AddAutoScalingGroupCapacityOptions {
    /**
     * Whether or not the containers can access the instance role
     *
     * @default false
     */
    readonly containersAccessInstanceRole?: boolean;
    /**
     * Give tasks this many seconds to complete when instances are being scaled in.
     *
     * Task draining adds a Lambda and a Lifecycle hook to your AutoScalingGroup
     * that will delay instance termination until all ECS tasks have drained from
     * the instance.
     *
     * Set to 0 to disable task draining.
     *
     * @default 300
     */
    readonly taskDrainTimeSeconds?: number;
}
/**
 * Properties for adding autoScalingGroup
 */
export interface AddCapacityOptions extends AddAutoScalingGroupCapacityOptions, autoscaling.CommonAutoScalingGroupProps {
    /**
     * The type of EC2 instance to launch into your Autoscaling Group
     */
    readonly instanceType: ec2.InstanceType;
}
export interface NamespaceOptions {
    /**
     * The domain name for the namespace, such as foo.com
     */
    readonly name: string;
    /**
     * The type of CloudMap Namespace to create in your cluster
     *
     * @default PrivateDns
     */
    readonly type?: NamespaceType;
    /**
     * The Amazon VPC that you want to associate the namespace with. Required for Private DNS namespaces
     *
     * @default VPC of the cluster for Private DNS Namespace, otherwise none
     */
    readonly vpc?: ec2.IVpcNetwork;
}
/**
 * The type of CloudMap namespace to create
 */
export declare enum NamespaceType {
    /**
     * Create a private DNS namespace
     */
    PrivateDns = "PrivateDns",
    /**
     * Create a public DNS namespace
     */
    PublicDns = "PublicDns"
}

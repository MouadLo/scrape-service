"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codedeploy = require("@aws-cdk/aws-codedeploy-api");
const aws_ec2_1 = require("@aws-cdk/aws-ec2");
const cdk = require("@aws-cdk/cdk");
const elasticloadbalancing_generated_1 = require("./elasticloadbalancing.generated");
var LoadBalancingProtocol;
(function (LoadBalancingProtocol) {
    LoadBalancingProtocol["Tcp"] = "tcp";
    LoadBalancingProtocol["Ssl"] = "ssl";
    LoadBalancingProtocol["Http"] = "http";
    LoadBalancingProtocol["Https"] = "https";
})(LoadBalancingProtocol = exports.LoadBalancingProtocol || (exports.LoadBalancingProtocol = {}));
/**
 * A load balancer with a single listener
 *
 * Routes to a fleet of of instances in a VPC.
 */
class LoadBalancer extends cdk.Construct {
    constructor(scope, id, props) {
        super(scope, id);
        /**
         * An object controlling specifically the connections for each listener added to this load balancer
         */
        this.listenerPorts = [];
        this.listeners = [];
        this.instancePorts = [];
        this.targets = [];
        this.securityGroup = new aws_ec2_1.SecurityGroup(this, 'SecurityGroup', { vpc: props.vpc, allowAllOutbound: false });
        this.connections = new aws_ec2_1.Connections({ securityGroups: [this.securityGroup] });
        // Depending on whether the ELB has public or internal IPs, pick the right backend subnets
        const subnets = props.internetFacing ? props.vpc.publicSubnets : props.vpc.privateSubnets;
        this.elb = new elasticloadbalancing_generated_1.CfnLoadBalancer(this, 'Resource', {
            securityGroups: [this.securityGroup.securityGroupId],
            subnets: subnets.map(s => s.subnetId),
            listeners: new cdk.Token(() => this.listeners),
            scheme: props.internetFacing ? 'internet-facing' : 'internal',
            healthCheck: props.healthCheck && healthCheckToJSON(props.healthCheck),
        });
        if (props.internetFacing) {
            this.elb.node.addDependency(...subnets.map(s => s.internetConnectivityEstablished));
        }
        ifUndefined(props.listeners, []).forEach(b => this.addListener(b));
        ifUndefined(props.targets, []).forEach(t => this.addTarget(t));
    }
    /**
     * Add a backend to the load balancer
     *
     * @returns A ListenerPort object that controls connections to the listener port
     */
    addListener(listener) {
        const protocol = ifUndefinedLazy(listener.externalProtocol, () => wellKnownProtocol(listener.externalPort));
        const instancePort = listener.internalPort || listener.externalPort;
        const instanceProtocol = ifUndefined(listener.internalProtocol, ifUndefined(tryWellKnownProtocol(instancePort), isHttpProtocol(protocol) ? LoadBalancingProtocol.Http : LoadBalancingProtocol.Tcp));
        this.listeners.push({
            loadBalancerPort: listener.externalPort.toString(),
            protocol,
            instancePort: instancePort.toString(),
            instanceProtocol,
            sslCertificateId: listener.sslCertificateId,
            policyNames: listener.policyNames
        });
        const port = new ListenerPort(this.securityGroup, new aws_ec2_1.TcpPort(listener.externalPort));
        // Allow connections on the public port for all supplied peers (default: everyone)
        ifUndefined(listener.allowConnectionsFrom, [new aws_ec2_1.AnyIPv4()]).forEach(peer => {
            port.connections.allowDefaultPortFrom(peer, `Default rule allow on ${listener.externalPort}`);
        });
        this.newInstancePort(instancePort);
        // Keep track using array so user can get to them even if they were all supplied in the constructor
        this.listenerPorts.push(port);
        return port;
    }
    addTarget(target) {
        target.attachToClassicLB(this);
        this.newTarget(target);
    }
    get loadBalancerName() {
        return this.elb.ref;
    }
    get loadBalancerCanonicalHostedZoneName() {
        return this.elb.loadBalancerCanonicalHostedZoneName;
    }
    get loadBalancerDnsName() {
        return this.elb.loadBalancerDnsName;
    }
    get loadBalancerSourceSecurityGroupGroupName() {
        return this.elb.loadBalancerSourceSecurityGroupGroupName;
    }
    get loadBalancerSourceSecurityGroupOwnerAlias() {
        return this.elb.loadBalancerSourceSecurityGroupOwnerAlias;
    }
    asCodeDeployLoadBalancer() {
        return {
            generation: codedeploy.LoadBalancerGeneration.First,
            name: this.loadBalancerName,
        };
    }
    /**
     * Allow connections to all existing targets on new instance port
     */
    newInstancePort(instancePort) {
        this.targets.forEach(t => this.allowTargetConnection(instancePort, t));
        // Keep track of port for future targets
        this.instancePorts.push(instancePort);
    }
    /**
     * Allow connections to target on all existing instance ports
     */
    newTarget(target) {
        this.instancePorts.forEach(p => this.allowTargetConnection(p, target));
        // Keep track of target for future listeners.
        this.targets.push(target);
    }
    /**
     * Allow connections for a single (port, target) pair
     */
    allowTargetConnection(instancePort, target) {
        this.connections.allowTo(target, new aws_ec2_1.TcpPort(instancePort), `Port ${instancePort} LB to fleet`);
    }
}
exports.LoadBalancer = LoadBalancer;
/**
 * Reference to a listener's port just created.
 *
 * This implements IConnectable with a default port (the port that an ELB
 * listener was just created on) for a given security group so that it can be
 * conveniently used just like any Connectable. E.g:
 *
 *    const listener = elb.addListener(...);
 *
 *    listener.connections.allowDefaultPortFromAnyIPv4();
 *    // or
 *    instance.connections.allowToDefaultPort(listener);
 */
class ListenerPort {
    constructor(securityGroup, defaultPortRange) {
        this.connections = new aws_ec2_1.Connections({ securityGroups: [securityGroup], defaultPortRange });
    }
}
exports.ListenerPort = ListenerPort;
function wellKnownProtocol(port) {
    const proto = tryWellKnownProtocol(port);
    if (!proto) {
        throw new Error(`Please supply protocol to go with port ${port}`);
    }
    return proto;
}
function tryWellKnownProtocol(port) {
    if (port === 80) {
        return LoadBalancingProtocol.Http;
    }
    if (port === 443) {
        return LoadBalancingProtocol.Https;
    }
    return undefined;
}
function isHttpProtocol(proto) {
    return proto === LoadBalancingProtocol.Https || proto === LoadBalancingProtocol.Http;
}
function ifUndefined(x, def) {
    return x != null ? x : def;
}
function ifUndefinedLazy(x, def) {
    return x != null ? x : def();
}
/**
 * Turn health check parameters into a parameter blob for the LB
 */
function healthCheckToJSON(healthCheck) {
    const protocol = ifUndefined(healthCheck.protocol, ifUndefined(tryWellKnownProtocol(healthCheck.port), LoadBalancingProtocol.Tcp));
    const path = protocol === LoadBalancingProtocol.Http || protocol === LoadBalancingProtocol.Https ? ifUndefined(healthCheck.path, "/") : "";
    const target = `${protocol.toUpperCase()}:${healthCheck.port}${path}`;
    return {
        healthyThreshold: ifUndefined(healthCheck.healthyThreshold, 2).toString(),
        interval: ifUndefined(healthCheck.interval, 30).toString(),
        target,
        timeout: ifUndefined(healthCheck.timeout, 5).toString(),
        unhealthyThreshold: ifUndefined(healthCheck.unhealthyThreshold, 5).toString(),
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZC1iYWxhbmNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxvYWQtYmFsYW5jZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwREFBMkQ7QUFDM0QsOENBRTZFO0FBQzdFLG9DQUFxQztBQUNyQyxxRkFBbUU7QUE0S25FLElBQVkscUJBS1g7QUFMRCxXQUFZLHFCQUFxQjtJQUMvQixvQ0FBVyxDQUFBO0lBQ1gsb0NBQVcsQ0FBQTtJQUNYLHNDQUFhLENBQUE7SUFDYix3Q0FBZSxDQUFBO0FBQ2pCLENBQUMsRUFMVyxxQkFBcUIsR0FBckIsNkJBQXFCLEtBQXJCLDZCQUFxQixRQUtoQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFhLFlBQWEsU0FBUSxHQUFHLENBQUMsU0FBUztJQWtCN0MsWUFBWSxLQUFvQixFQUFFLEVBQVUsRUFBRSxLQUF3QjtRQUNwRSxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBYm5COztXQUVHO1FBQ2Esa0JBQWEsR0FBbUIsRUFBRSxDQUFDO1FBSWxDLGNBQVMsR0FBd0MsRUFBRSxDQUFDO1FBRXBELGtCQUFhLEdBQWEsRUFBRSxDQUFDO1FBQzdCLFlBQU8sR0FBMEIsRUFBRSxDQUFDO1FBS25ELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSx1QkFBYSxDQUFDLElBQUksRUFBRSxlQUFlLEVBQUUsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQzNHLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxxQkFBVyxDQUFDLEVBQUUsY0FBYyxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUU3RSwwRkFBMEY7UUFDMUYsTUFBTSxPQUFPLEdBQWlCLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFL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RUFBRSxXQUFXLENBQUMsV0FBVyxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRTtRQUN6RSxRQUFRLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFO1FBQzFELE1BQU07UUFDTixPQUFPLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFO1FBQ3ZELGtCQUFrQixFQUFFLFdBQVcsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFO0tBQzlFLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvZGVkZXBsb3kgPSByZXF1aXJlKCdAYXdzLWNkay9hd3MtY29kZWRlcGxveS1hcGknKTtcbmltcG9ydCB7XG4gIEFueUlQdjQsIENvbm5lY3Rpb25zLCBJQ29ubmVjdGFibGUsIElQb3J0UmFuZ2UsIElTZWN1cml0eUdyb3VwLFxuICBJVnBjTmV0d29yaywgSVZwY1N1Ym5ldCwgU2VjdXJpdHlHcm91cCwgVGNwUG9ydCAgfSBmcm9tICdAYXdzLWNkay9hd3MtZWMyJztcbmltcG9ydCBjZGsgPSByZXF1aXJlKCdAYXdzLWNkay9jZGsnKTtcbmltcG9ydCB7IENmbkxvYWRCYWxhbmNlciB9IGZyb20gJy4vZWxhc3RpY2xvYWRiYWxhbmNpbmcuZ2VuZXJhdGVkJztcblxuLyoqXG4gKiBDb25zdHJ1Y3Rpb24gcHJvcGVydGllcyBmb3IgYSBMb2FkQmFsYW5jZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2FkQmFsYW5jZXJQcm9wcyB7XG4gIC8qKlxuICAgKiBWUEMgbmV0d29yayBvZiB0aGUgZmxlZXQgaW5zdGFuY2VzXG4gICAqL1xuICByZWFkb25seSB2cGM6IElWcGNOZXR3b3JrO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgaXMgYW4gaW50ZXJuZXQtZmFjaW5nIExvYWQgQmFsYW5jZXJcbiAgICpcbiAgICogVGhpcyBjb250cm9scyB3aGV0aGVyIHRoZSBMQiBoYXMgYSBwdWJsaWMgSVAgYWRkcmVzcyBhc3NpZ25lZC4gSXQgZG9lc1xuICAgKiBub3Qgb3BlbiB1cCB0aGUgTG9hZCBCYWxhbmNlcidzIHNlY3VyaXR5IGdyb3VwcyB0byBwdWJsaWMgaW50ZXJuZXQgYWNjZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaW50ZXJuZXRGYWNpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGF0IGxpc3RlbmVycyB0byBzZXQgdXAgZm9yIHRoZSBsb2FkIGJhbGFuY2VyLlxuICAgKlxuICAgKiBDYW4gYWxzbyBiZSBhZGRlZCBieSAuYWRkTGlzdGVuZXIoKVxuICAgKi9cbiAgcmVhZG9ubHkgbGlzdGVuZXJzPzogTG9hZEJhbGFuY2VyTGlzdGVuZXJbXTtcblxuICAvKipcbiAgICogV2hhdCB0YXJnZXRzIHRvIGxvYWQgYmFsYW5jZSB0by5cbiAgICpcbiAgICogQ2FuIGFsc28gYmUgYWRkZWQgYnkgLmFkZFRhcmdldCgpXG4gICAqL1xuICByZWFkb25seSB0YXJnZXRzPzogSUxvYWRCYWxhbmNlclRhcmdldFtdO1xuXG4gIC8qKlxuICAgKiBIZWFsdGggY2hlY2sgc2V0dGluZ3MgZm9yIHRoZSBsb2FkIGJhbGFuY2luZyB0YXJnZXRzLlxuICAgKlxuICAgKiBOb3QgcmVxdWlyZWQgYnV0IHJlY29tbWVuZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgaGVhbHRoQ2hlY2s/OiBIZWFsdGhDaGVjaztcbn1cblxuLyoqXG4gKiBEZXNjcmliZSB0aGUgaGVhbHRoIGNoZWNrIHRvIGEgbG9hZCBiYWxhbmNlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrIHtcbiAgLyoqXG4gICAqIFdoYXQgcG9ydCBudW1iZXIgdG8gaGVhbHRoIGNoZWNrIG9uXG4gICAqL1xuICByZWFkb25seSBwb3J0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFdoYXQgcHJvdG9jb2wgdG8gdXNlIGZvciBoZWFsdGggY2hlY2tpbmdcbiAgICpcbiAgICogVGhlIHByb3RvY29sIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZCBmcm9tIHRoZSBwb3J0IGlmIGl0J3Mgbm90IHN1cHBsaWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBBdXRvbWF0aWNcbiAgICovXG4gIHJlYWRvbmx5IHByb3RvY29sPzogTG9hZEJhbGFuY2luZ1Byb3RvY29sO1xuXG4gIC8qKlxuICAgKiBXaGF0IHBhdGggdG8gdXNlIGZvciBIVFRQIG9yIEhUVFBTIGhlYWx0aCBjaGVjayAobXVzdCByZXR1cm4gMjAwKVxuICAgKlxuICAgKiBGb3IgU1NMIGFuZCBUQ1AgaGVhbHRoIGNoZWNrcywgYWNjZXB0aW5nIGNvbm5lY3Rpb25zIGlzIGVub3VnaCB0byBiZSBjb25zaWRlcmVkXG4gICAqIGhlYWx0aHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IFwiL1wiXG4gICAqL1xuICByZWFkb25seSBwYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBZnRlciBob3cgbWFueSBzdWNjZXNzZnVsIGNoZWNrcyBpcyBhbiBpbnN0YW5jZSBjb25zaWRlcmVkIGhlYWx0aHlcbiAgICpcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgcmVhZG9ubHkgaGVhbHRoeVRocmVzaG9sZD86IG51bWJlcjtcblxuICAvKipcbiAgICogQWZ0ZXIgaG93IG1hbnkgdW5zdWNjZXNzZnVsIGNoZWNrcyBpcyBhbiBpbnN0YW5jZSBjb25zaWRlcmVkIHVuaGVhbHRoeVxuICAgKlxuICAgKiBAZGVmYXVsdCA1XG4gICAqL1xuICByZWFkb25seSB1bmhlYWx0aHlUaHJlc2hvbGQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBzZWNvbmRzIGJldHdlZW4gaGVhbHRoIGNoZWNrc1xuICAgKlxuICAgKiBAZGVmYXVsdCAzMFxuICAgKi9cbiAgcmVhZG9ubHkgaW50ZXJ2YWw/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhlYWx0aCBjaGVjayB0aW1lb3V0XG4gICAqXG4gICAqIEBkZWZhdWx0IDVcbiAgICovXG4gIHJlYWRvbmx5IHRpbWVvdXQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHRoYXQgaXMgZ29pbmcgdG8gYmUgaW1wbGVtZW50ZWQgYnkgY29uc3RydWN0cyB0aGF0IHlvdSBjYW4gbG9hZCBiYWxhbmNlIHRvXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUxvYWRCYWxhbmNlclRhcmdldCBleHRlbmRzIElDb25uZWN0YWJsZSB7XG4gIC8qKlxuICAgKiBBdHRhY2ggbG9hZC1iYWxhbmNlZCB0YXJnZXQgdG8gYSBjbGFzc2ljIEVMQlxuICAgKi9cbiAgYXR0YWNoVG9DbGFzc2ljTEIobG9hZEJhbGFuY2VyOiBMb2FkQmFsYW5jZXIpOiB2b2lkO1xufVxuXG4vKipcbiAqIEFkZCBhIGJhY2tlbmQgdG8gdGhlIGxvYWQgYmFsYW5jZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2FkQmFsYW5jZXJMaXN0ZW5lciB7XG4gIC8qKlxuICAgKiBFeHRlcm5hbCBsaXN0ZW5pbmcgcG9ydFxuICAgKi9cbiAgcmVhZG9ubHkgZXh0ZXJuYWxQb3J0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFdoYXQgcHVibGljIHByb3RvY29sIHRvIHVzZSBmb3IgbG9hZCBiYWxhbmNpbmdcbiAgICpcbiAgICogRWl0aGVyICd0Y3AnLCAnc3NsJywgJ2h0dHAnIG9yICdodHRwcycuXG4gICAqXG4gICAqIE1heSBiZSBvbWl0dGVkIGlmIHRoZSBleHRlcm5hbCBwb3J0IGlzIGVpdGhlciA4MCBvciA0NDMuXG4gICAqL1xuICByZWFkb25seSBleHRlcm5hbFByb3RvY29sPzogTG9hZEJhbGFuY2luZ1Byb3RvY29sO1xuXG4gIC8qKlxuICAgKiBJbnN0YW5jZSBsaXN0ZW5pbmcgcG9ydFxuICAgKlxuICAgKiBTYW1lIGFzIHRoZSBleHRlcm5hbFBvcnQgaWYgbm90IHNwZWNpZmllZC5cbiAgICpcbiAgICogQGRlZmF1bHQgZXh0ZXJuYWxQb3J0XG4gICAqL1xuICByZWFkb25seSBpbnRlcm5hbFBvcnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFdoYXQgcHVibGljIHByb3RvY29sIHRvIHVzZSBmb3IgbG9hZCBiYWxhbmNpbmdcbiAgICpcbiAgICogRWl0aGVyICd0Y3AnLCAnc3NsJywgJ2h0dHAnIG9yICdodHRwcycuXG4gICAqXG4gICAqIE1heSBiZSBvbWl0dGVkIGlmIHRoZSBpbnRlcm5hbCBwb3J0IGlzIGVpdGhlciA4MCBvciA0NDMuXG4gICAqXG4gICAqIFRoZSBpbnN0YW5jZSBwcm90b2NvbCBpcyAndGNwJyBpZiB0aGUgZnJvbnQtZW5kIHByb3RvY29sXG4gICAqIGlzICd0Y3AnIG9yICdzc2wnLCB0aGUgaW5zdGFuY2UgcHJvdG9jb2wgaXMgJ2h0dHAnIGlmIHRoZVxuICAgKiBmcm9udC1lbmQgcHJvdG9jb2wgaXMgJ2h0dHBzJy5cbiAgICovXG4gIHJlYWRvbmx5IGludGVybmFsUHJvdG9jb2w/OiBMb2FkQmFsYW5jaW5nUHJvdG9jb2w7XG5cbiAgLyoqXG4gICAqIFNTTCBwb2xpY3kgbmFtZXNcbiAgICovXG4gIHJlYWRvbmx5IHBvbGljeU5hbWVzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIElEIG9mIFNTTCBjZXJ0aWZpY2F0ZVxuICAgKi9cbiAgcmVhZG9ubHkgc3NsQ2VydGlmaWNhdGVJZD86IHN0cmluZztcblxuICAvKipcbiAgICogQWxsb3cgY29ubmVjdGlvbnMgdG8gdGhlIGxvYWQgYmFsYW5jZXIgZnJvbSB0aGUgZ2l2ZW4gc2V0IG9mIGNvbm5lY3Rpb24gcGVlcnNcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgY29ubmVjdGlvbnMgd2lsbCBiZSBhbGxvd2VkIGZyb20gYW55d2hlcmUuIFNldCB0aGlzIHRvIGFuIGVtcHR5IGxpc3RcbiAgICogdG8gZGVueSBjb25uZWN0aW9ucywgb3Igc3VwcGx5IGEgY3VzdG9tIGxpc3Qgb2YgcGVlcnMgdG8gYWxsb3cgY29ubmVjdGlvbnMgZnJvbVxuICAgKiAoSVAgcmFuZ2VzIG9yIHNlY3VyaXR5IGdyb3VwcykuXG4gICAqXG4gICAqIEBkZWZhdWx0IEFueXdoZXJlXG4gICAqL1xuICByZWFkb25seSBhbGxvd0Nvbm5lY3Rpb25zRnJvbT86IElDb25uZWN0YWJsZVtdO1xufVxuXG5leHBvcnQgZW51bSBMb2FkQmFsYW5jaW5nUHJvdG9jb2wge1xuICBUY3AgPSAndGNwJyxcbiAgU3NsID0gJ3NzbCcsXG4gIEh0dHAgPSAnaHR0cCcsXG4gIEh0dHBzID0gJ2h0dHBzJ1xufVxuXG4vKipcbiAqIEEgbG9hZCBiYWxhbmNlciB3aXRoIGEgc2luZ2xlIGxpc3RlbmVyXG4gKlxuICogUm91dGVzIHRvIGEgZmxlZXQgb2Ygb2YgaW5zdGFuY2VzIGluIGEgVlBDLlxuICovXG5leHBvcnQgY2xhc3MgTG9hZEJhbGFuY2VyIGV4dGVuZHMgY2RrLkNvbnN0cnVjdCBpbXBsZW1lbnRzIElDb25uZWN0YWJsZSwgY29kZWRlcGxveS5JTG9hZEJhbGFuY2VyIHtcbiAgLyoqXG4gICAqIENvbnRyb2wgYWxsIGNvbm5lY3Rpb25zIGZyb20gYW5kIHRvIHRoaXMgbG9hZCBiYWxhbmNlclxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNvbm5lY3Rpb25zOiBDb25uZWN0aW9ucztcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRyb2xsaW5nIHNwZWNpZmljYWxseSB0aGUgY29ubmVjdGlvbnMgZm9yIGVhY2ggbGlzdGVuZXIgYWRkZWQgdG8gdGhpcyBsb2FkIGJhbGFuY2VyXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbGlzdGVuZXJQb3J0czogTGlzdGVuZXJQb3J0W10gPSBbXTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGVsYjogQ2ZuTG9hZEJhbGFuY2VyO1xuICBwcml2YXRlIHJlYWRvbmx5IHNlY3VyaXR5R3JvdXA6IFNlY3VyaXR5R3JvdXA7XG4gIHByaXZhdGUgcmVhZG9ubHkgbGlzdGVuZXJzOiBDZm5Mb2FkQmFsYW5jZXIuTGlzdGVuZXJzUHJvcGVydHlbXSA9IFtdO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5zdGFuY2VQb3J0czogbnVtYmVyW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXRzOiBJTG9hZEJhbGFuY2VyVGFyZ2V0W10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogY2RrLkNvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IExvYWRCYWxhbmNlclByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIHRoaXMuc2VjdXJpdHlHcm91cCA9IG5ldyBTZWN1cml0eUdyb3VwKHRoaXMsICdTZWN1cml0eUdyb3VwJywgeyB2cGM6IHByb3BzLnZwYywgYWxsb3dBbGxPdXRib3VuZDogZmFsc2UgfSk7XG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IG5ldyBDb25uZWN0aW9ucyh7IHNlY3VyaXR5R3JvdXBzOiBbdGhpcy5zZWN1cml0eUdyb3VwXSB9KTtcblxuICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBFTEIgaGFzIHB1YmxpYyBvciBpbnRlcm5hbCBJUHMsIHBpY2sgdGhlIHJpZ2h0IGJhY2tlbmQgc3VibmV0c1xuICAgIGNvbnN0IHN1Ym5ldHM6IElWcGNTdWJuZXRbXSA9IHByb3BzLmludGVybmV0RmFjaW5nID8gcHJvcHMudnBjLnB1YmxpY1N1Ym5ldHMgOiBwcm9wcy52cGMucHJpdmF0ZVN1Ym5ldHM7XG5cbiAgICB0aGlzLmVsYiA9IG5ldyBDZm5Mb2FkQmFsYW5jZXIodGhpcywgJ1Jlc291cmNlJywge1xuICAgICAgc2VjdXJpdHlHcm91cHM6IFsgdGhpcy5zZWN1cml0eUdyb3VwLnNlY3VyaXR5R3JvdXBJZCBdLFxuICAgICAgc3VibmV0czogc3VibmV0cy5tYXAocyA9PiBzLnN1Ym5ldElkKSxcbiAgICAgIGxpc3RlbmVyczogbmV3IGNkay5Ub2tlbigoKSA9PiB0aGlzLmxpc3RlbmVycyksXG4gICAgICBzY2hlbWU6IHByb3BzLmludGVybmV0RmFjaW5nID8gJ2ludGVybmV0LWZhY2luZycgOiAnaW50ZXJuYWwnLFxuICAgICAgaGVhbHRoQ2hlY2s6IHByb3BzLmhlYWx0aENoZWNrICYmIGhlYWx0aENoZWNrVG9KU09OKHByb3BzLmhlYWx0aENoZWNrKSxcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuaW50ZXJuZXRGYWNpbmcpIHtcbiAgICAgIHRoaXMuZWxiLm5vZGUuYWRkRGVwZW5kZW5jeSguLi5zdWJuZXRzLm1hcChzID0+IHMuaW50ZXJuZXRDb25uZWN0aXZpdHlFc3RhYmxpc2hlZCkpO1xuICAgIH1cblxuICAgIGlmVW5kZWZpbmVkKHByb3BzLmxpc3RlbmVycywgW10pLmZvckVhY2goYiA9PiB0aGlzLmFkZExpc3RlbmVyKGIpKTtcbiAgICBpZlVuZGVmaW5lZChwcm9wcy50YXJnZXRzLCBbXSkuZm9yRWFjaCh0ID0+IHRoaXMuYWRkVGFyZ2V0KHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBiYWNrZW5kIHRvIHRoZSBsb2FkIGJhbGFuY2VyXG4gICAqXG4gICAqIEByZXR1cm5zIEEgTGlzdGVuZXJQb3J0IG9iamVjdCB0aGF0IGNvbnRyb2xzIGNvbm5lY3Rpb25zIHRvIHRoZSBsaXN0ZW5lciBwb3J0XG4gICAqL1xuICBwdWJsaWMgYWRkTGlzdGVuZXIobGlzdGVuZXI6IExvYWRCYWxhbmNlckxpc3RlbmVyKTogTGlzdGVuZXJQb3J0IHtcbiAgICBjb25zdCBwcm90b2NvbCA9IGlmVW5kZWZpbmVkTGF6eShsaXN0ZW5lci5leHRlcm5hbFByb3RvY29sLCAoKSA9PiB3ZWxsS25vd25Qcm90b2NvbChsaXN0ZW5lci5leHRlcm5hbFBvcnQpKTtcbiAgICBjb25zdCBpbnN0YW5jZVBvcnQgPSBsaXN0ZW5lci5pbnRlcm5hbFBvcnQgfHwgbGlzdGVuZXIuZXh0ZXJuYWxQb3J0O1xuICAgIGNvbnN0IGluc3RhbmNlUHJvdG9jb2wgPSBpZlVuZGVmaW5lZChsaXN0ZW5lci5pbnRlcm5hbFByb3RvY29sLFxuICAgICAgICAgICAgICAgICBpZlVuZGVmaW5lZCh0cnlXZWxsS25vd25Qcm90b2NvbChpbnN0YW5jZVBvcnQpLFxuICAgICAgICAgICAgICAgICBpc0h0dHBQcm90b2NvbChwcm90b2NvbCkgPyBMb2FkQmFsYW5jaW5nUHJvdG9jb2wuSHR0cCA6IExvYWRCYWxhbmNpbmdQcm90b2NvbC5UY3ApKTtcblxuICAgIHRoaXMubGlzdGVuZXJzLnB1c2goe1xuICAgICAgbG9hZEJhbGFuY2VyUG9ydDogbGlzdGVuZXIuZXh0ZXJuYWxQb3J0LnRvU3RyaW5nKCksXG4gICAgICBwcm90b2NvbCxcbiAgICAgIGluc3RhbmNlUG9ydDogaW5zdGFuY2VQb3J0LnRvU3RyaW5nKCksXG4gICAgICBpbnN0YW5jZVByb3RvY29sLFxuICAgICAgc3NsQ2VydGlmaWNhdGVJZDogbGlzdGVuZXIuc3NsQ2VydGlmaWNhdGVJZCxcbiAgICAgIHBvbGljeU5hbWVzOiBsaXN0ZW5lci5wb2xpY3lOYW1lc1xuICAgIH0pO1xuXG4gICAgY29uc3QgcG9ydCA9IG5ldyBMaXN0ZW5lclBvcnQodGhpcy5zZWN1cml0eUdyb3VwLCBuZXcgVGNwUG9ydChsaXN0ZW5lci5leHRlcm5hbFBvcnQpKTtcblxuICAgIC8vIEFsbG93IGNvbm5lY3Rpb25zIG9uIHRoZSBwdWJsaWMgcG9ydCBmb3IgYWxsIHN1cHBsaWVkIHBlZXJzIChkZWZhdWx0OiBldmVyeW9uZSlcbiAgICBpZlVuZGVmaW5lZChsaXN0ZW5lci5hbGxvd0Nvbm5lY3Rpb25zRnJvbSwgW25ldyBBbnlJUHY0KCldKS5mb3JFYWNoKHBlZXIgPT4ge1xuICAgICAgcG9ydC5jb25uZWN0aW9ucy5hbGxvd0RlZmF1bHRQb3J0RnJvbShwZWVyLCBgRGVmYXVsdCBydWxlIGFsbG93IG9uICR7bGlzdGVuZXIuZXh0ZXJuYWxQb3J0fWApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5uZXdJbnN0YW5jZVBvcnQoaW5zdGFuY2VQb3J0KTtcblxuICAgIC8vIEtlZXAgdHJhY2sgdXNpbmcgYXJyYXkgc28gdXNlciBjYW4gZ2V0IHRvIHRoZW0gZXZlbiBpZiB0aGV5IHdlcmUgYWxsIHN1cHBsaWVkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgIHRoaXMubGlzdGVuZXJQb3J0cy5wdXNoKHBvcnQpO1xuXG4gICAgcmV0dXJuIHBvcnQ7XG4gIH1cblxuICBwdWJsaWMgYWRkVGFyZ2V0KHRhcmdldDogSUxvYWRCYWxhbmNlclRhcmdldCkge1xuICAgIHRhcmdldC5hdHRhY2hUb0NsYXNzaWNMQih0aGlzKTtcblxuICAgIHRoaXMubmV3VGFyZ2V0KHRhcmdldCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGxvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxiLnJlZjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbG9hZEJhbGFuY2VyQ2Fub25pY2FsSG9zdGVkWm9uZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxiLmxvYWRCYWxhbmNlckNhbm9uaWNhbEhvc3RlZFpvbmVOYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBsb2FkQmFsYW5jZXJEbnNOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmVsYi5sb2FkQmFsYW5jZXJEbnNOYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBsb2FkQmFsYW5jZXJTb3VyY2VTZWN1cml0eUdyb3VwR3JvdXBOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmVsYi5sb2FkQmFsYW5jZXJTb3VyY2VTZWN1cml0eUdyb3VwR3JvdXBOYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBsb2FkQmFsYW5jZXJTb3VyY2VTZWN1cml0eUdyb3VwT3duZXJBbGlhcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGIubG9hZEJhbGFuY2VyU291cmNlU2VjdXJpdHlHcm91cE93bmVyQWxpYXM7XG4gIH1cblxuICBwdWJsaWMgYXNDb2RlRGVwbG95TG9hZEJhbGFuY2VyKCk6IGNvZGVkZXBsb3kuSUxvYWRCYWxhbmNlclByb3BzIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGlvbjogY29kZWRlcGxveS5Mb2FkQmFsYW5jZXJHZW5lcmF0aW9uLkZpcnN0LFxuICAgICAgbmFtZTogdGhpcy5sb2FkQmFsYW5jZXJOYW1lLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgY29ubmVjdGlvbnMgdG8gYWxsIGV4aXN0aW5nIHRhcmdldHMgb24gbmV3IGluc3RhbmNlIHBvcnRcbiAgICovXG4gIHByaXZhdGUgbmV3SW5zdGFuY2VQb3J0KGluc3RhbmNlUG9ydDogbnVtYmVyKSB7XG4gICAgdGhpcy50YXJnZXRzLmZvckVhY2godCA9PiB0aGlzLmFsbG93VGFyZ2V0Q29ubmVjdGlvbihpbnN0YW5jZVBvcnQsIHQpKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgcG9ydCBmb3IgZnV0dXJlIHRhcmdldHNcbiAgICB0aGlzLmluc3RhbmNlUG9ydHMucHVzaChpbnN0YW5jZVBvcnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IGNvbm5lY3Rpb25zIHRvIHRhcmdldCBvbiBhbGwgZXhpc3RpbmcgaW5zdGFuY2UgcG9ydHNcbiAgICovXG4gIHByaXZhdGUgbmV3VGFyZ2V0KHRhcmdldDogSUxvYWRCYWxhbmNlclRhcmdldCkge1xuICAgIHRoaXMuaW5zdGFuY2VQb3J0cy5mb3JFYWNoKHAgPT4gdGhpcy5hbGxvd1RhcmdldENvbm5lY3Rpb24ocCwgdGFyZ2V0KSk7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRhcmdldCBmb3IgZnV0dXJlIGxpc3RlbmVycy5cbiAgICB0aGlzLnRhcmdldHMucHVzaCh0YXJnZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IGNvbm5lY3Rpb25zIGZvciBhIHNpbmdsZSAocG9ydCwgdGFyZ2V0KSBwYWlyXG4gICAqL1xuICBwcml2YXRlIGFsbG93VGFyZ2V0Q29ubmVjdGlvbihpbnN0YW5jZVBvcnQ6IG51bWJlciwgdGFyZ2V0OiBJTG9hZEJhbGFuY2VyVGFyZ2V0KSB7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5hbGxvd1RvKFxuICAgICAgdGFyZ2V0LFxuICAgICAgbmV3IFRjcFBvcnQoaW5zdGFuY2VQb3J0KSxcbiAgICAgIGBQb3J0ICR7aW5zdGFuY2VQb3J0fSBMQiB0byBmbGVldGApO1xuICB9XG59XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIGEgbGlzdGVuZXIncyBwb3J0IGp1c3QgY3JlYXRlZC5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgSUNvbm5lY3RhYmxlIHdpdGggYSBkZWZhdWx0IHBvcnQgKHRoZSBwb3J0IHRoYXQgYW4gRUxCXG4gKiBsaXN0ZW5lciB3YXMganVzdCBjcmVhdGVkIG9uKSBmb3IgYSBnaXZlbiBzZWN1cml0eSBncm91cCBzbyB0aGF0IGl0IGNhbiBiZVxuICogY29udmVuaWVudGx5IHVzZWQganVzdCBsaWtlIGFueSBDb25uZWN0YWJsZS4gRS5nOlxuICpcbiAqICAgIGNvbnN0IGxpc3RlbmVyID0gZWxiLmFkZExpc3RlbmVyKC4uLik7XG4gKlxuICogICAgbGlzdGVuZXIuY29ubmVjdGlvbnMuYWxsb3dEZWZhdWx0UG9ydEZyb21BbnlJUHY0KCk7XG4gKiAgICAvLyBvclxuICogICAgaW5zdGFuY2UuY29ubmVjdGlvbnMuYWxsb3dUb0RlZmF1bHRQb3J0KGxpc3RlbmVyKTtcbiAqL1xuZXhwb3J0IGNsYXNzIExpc3RlbmVyUG9ydCBpbXBsZW1lbnRzIElDb25uZWN0YWJsZSB7XG4gIHB1YmxpYyByZWFkb25seSBjb25uZWN0aW9uczogQ29ubmVjdGlvbnM7XG5cbiAgY29uc3RydWN0b3Ioc2VjdXJpdHlHcm91cDogSVNlY3VyaXR5R3JvdXAsIGRlZmF1bHRQb3J0UmFuZ2U6IElQb3J0UmFuZ2UpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zID0gbmV3IENvbm5lY3Rpb25zKHsgc2VjdXJpdHlHcm91cHM6IFtzZWN1cml0eUdyb3VwXSAsIGRlZmF1bHRQb3J0UmFuZ2UgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2VsbEtub3duUHJvdG9jb2wocG9ydDogbnVtYmVyKTogTG9hZEJhbGFuY2luZ1Byb3RvY29sIHtcbiAgY29uc3QgcHJvdG8gPSB0cnlXZWxsS25vd25Qcm90b2NvbChwb3J0KTtcbiAgaWYgKCFwcm90bykge1xuICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIHN1cHBseSBwcm90b2NvbCB0byBnbyB3aXRoIHBvcnQgJHtwb3J0fWApO1xuICB9XG4gIHJldHVybiBwcm90bztcbn1cblxuZnVuY3Rpb24gdHJ5V2VsbEtub3duUHJvdG9jb2wocG9ydDogbnVtYmVyKTogTG9hZEJhbGFuY2luZ1Byb3RvY29sIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBvcnQgPT09IDgwKSB7IHJldHVybiBMb2FkQmFsYW5jaW5nUHJvdG9jb2wuSHR0cDsgfVxuICBpZiAocG9ydCA9PT0gNDQzKSB7IHJldHVybiBMb2FkQmFsYW5jaW5nUHJvdG9jb2wuSHR0cHM7IH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNIdHRwUHJvdG9jb2wocHJvdG86IExvYWRCYWxhbmNpbmdQcm90b2NvbCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcHJvdG8gPT09IExvYWRCYWxhbmNpbmdQcm90b2NvbC5IdHRwcyB8fCBwcm90byA9PT0gTG9hZEJhbGFuY2luZ1Byb3RvY29sLkh0dHA7XG59XG5cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkPFQ+KHg6IFQgfCB1bmRlZmluZWQsIGRlZjogVCk6IFQge1xuICByZXR1cm4geCAhPSBudWxsID8geCA6IGRlZjtcbn1cblxuZnVuY3Rpb24gaWZVbmRlZmluZWRMYXp5PFQ+KHg6IFQgfCB1bmRlZmluZWQsIGRlZjogKCkgPT4gVCk6IFQge1xuICByZXR1cm4geCAhPSBudWxsID8geCA6IGRlZigpO1xufVxuXG4vKipcbiAqIFR1cm4gaGVhbHRoIGNoZWNrIHBhcmFtZXRlcnMgaW50byBhIHBhcmFtZXRlciBibG9iIGZvciB0aGUgTEJcbiAqL1xuZnVuY3Rpb24gaGVhbHRoQ2hlY2tUb0pTT04oaGVhbHRoQ2hlY2s6IEhlYWx0aENoZWNrKTogQ2ZuTG9hZEJhbGFuY2VyLkhlYWx0aENoZWNrUHJvcGVydHkge1xuICBjb25zdCBwcm90b2NvbCA9IGlmVW5kZWZpbmVkKGhlYWx0aENoZWNrLnByb3RvY29sLFxuICAgICAgICAgICBpZlVuZGVmaW5lZCh0cnlXZWxsS25vd25Qcm90b2NvbChoZWFsdGhDaGVjay5wb3J0KSxcbiAgICAgICAgICAgTG9hZEJhbGFuY2luZ1Byb3RvY29sLlRjcCkpO1xuXG4gIGNvbnN0IHBhdGggPSBwcm90b2NvbCA9PT0gTG9hZEJhbGFuY2luZ1Byb3RvY29sLkh0dHAgfHwgcHJvdG9jb2wgPT09IExvYWRCYWxhbmNpbmdQcm90b2NvbC5IdHRwcyA/IGlmVW5kZWZpbmVkKGhlYWx0aENoZWNrLnBhdGgsIFwiL1wiKSA6IFwiXCI7XG5cbiAgY29uc3QgdGFyZ2V0ID0gYCR7cHJvdG9jb2wudG9VcHBlckNhc2UoKX06JHtoZWFsdGhDaGVjay5wb3J0fSR7cGF0aH1gO1xuXG4gIHJldHVybiB7XG4gICAgaGVhbHRoeVRocmVzaG9sZDogaWZVbmRlZmluZWQoaGVhbHRoQ2hlY2suaGVhbHRoeVRocmVzaG9sZCwgMikudG9TdHJpbmcoKSxcbiAgICBpbnRlcnZhbDogaWZVbmRlZmluZWQoaGVhbHRoQ2hlY2suaW50ZXJ2YWwsIDMwKS50b1N0cmluZygpLFxuICAgIHRhcmdldCxcbiAgICB0aW1lb3V0OiBpZlVuZGVmaW5lZChoZWFsdGhDaGVjay50aW1lb3V0LCA1KS50b1N0cmluZygpLFxuICAgIHVuaGVhbHRoeVRocmVzaG9sZDogaWZVbmRlZmluZWQoaGVhbHRoQ2hlY2sudW5oZWFsdGh5VGhyZXNob2xkLCA1KS50b1N0cmluZygpLFxuICB9O1xufVxuIl19
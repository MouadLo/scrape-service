"use strict";
const assert_1 = require("@aws-cdk/assert");
const aws_ec2_1 = require("@aws-cdk/aws-ec2");
const cdk_1 = require("@aws-cdk/cdk");
const lib_1 = require("../lib");
class FakeTarget {
    constructor() {
        this.connections = new aws_ec2_1.Connections({
            securityGroupRule: new aws_ec2_1.CidrIPv4('666.666.666.666/666')
        });
    }
    attachToClassicLB(_loadBalancer) {
        // Nothing to do. Normally we set a property on ourselves so
        // our instances know to bind to the LB on startup.
    }
}
module.exports = {
    'test specifying nonstandard port works'(test) {
        const stack = new cdk_1.Stack(undefined, undefined, { env: { account: '1234', region: 'test' } });
        stack.node.setContext('availability-zones:1234:test', ['test-1a', 'test-1b']);
        const vpc = new aws_ec2_1.VpcNetwork(stack, 'VCP');
        const lb = new lib_1.LoadBalancer(stack, 'LB', { vpc });
        lb.addListener({
            externalProtocol: lib_1.LoadBalancingProtocol.Http,
            externalPort: 8080,
            internalProtocol: lib_1.LoadBalancingProtocol.Http,
            internalPort: 8080,
        });
        assert_1.expect(stack).to(assert_1.haveResource("AWS::ElasticLoadBalancing::LoadBalancer", {
            Listeners: [{
                    InstancePort: "8080",
                    InstanceProtocol: "http",
                    LoadBalancerPort: "8080",
                    Protocol: "http"
                }]
        }));
        test.done();
    },
    'add a health check'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new aws_ec2_1.VpcNetwork(stack, 'VCP');
        // WHEN
        new lib_1.LoadBalancer(stack, 'LB', {
            vpc,
            healthCheck: {
                interval: 60,
                path: '/ping',
                protocol: lib_1.LoadBalancingProtocol.Https,
                port: 443,
            }
        });
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource("AWS::ElasticLoadBalancing::LoadBalancer", {
            HealthCheck: {
                HealthyThreshold: "2",
                Interval: "60",
                Target: "HTTPS:443/ping",
                Timeout: "5",
                UnhealthyThreshold: "5"
            },
        }));
        test.done();
    },
    'add a listener and load balancing target'(test) {
        // GIVEN
        const stack = new cdk_1.Stack();
        const vpc = new aws_ec2_1.VpcNetwork(stack, 'VCP');
        const elb = new lib_1.LoadBalancer(stack, 'LB', {
            vpc,
            healthCheck: {
                interval: 60,
                path: '/ping',
                protocol: lib_1.LoadBalancingProtocol.Https,
                port: 443,
            }
        });
        // WHEN
        elb.addListener({ externalPort: 80, internalPort: 8080 });
        elb.addTarget(new FakeTarget());
        // THEN: at the very least it added a security group rule for the backend
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            SecurityGroupEgress: [
                {
                    Description: 'Port 8080 LB to fleet',
                    CidrIp: "666.666.666.666/666",
                    FromPort: 8080,
                    IpProtocol: "tcp",
                    ToPort: 8080
                }
            ],
        }));
        test.done();
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5sb2FkYmFsYW5jZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXN0LmxvYWRiYWxhbmNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsNENBQXVEO0FBQ3ZELDhDQUFxRTtBQUNyRSxzQ0FBcUM7QUFFckMsZ0NBQWtGO0FBOEZsRixNQUFNLFVBQVU7SUFBaEI7UUFDa0IsZ0JBQVcsR0FBRyxJQUFJLHFCQUFXLENBQUM7WUFDNUMsaUJBQWlCLEVBQUUsSUFBSSxrQkFBUSxDQUFDLHFCQUFxQixDQUFDO1NBQ3ZELENBQUMsQ0FBQztJQU1MLENBQUM7SUFKUSxpQkFBaUIsQ0FBQyxhQUEyQjtRQUNsRCw0REFBNEQ7UUFDNUQsbURBQW1EO0lBQ3JELENBQUM7Q0FDRjtBQXJHRCxpQkFBUztJQUNQLHdDQUF3QyxDQUFDLElBQVU7UUFDakQsTUFBTSxLQUFLLEdBQUcsSUFBSSxXQUFLLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxFQUFDLENBQUMsQ0FBQztRQUMzRixLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyw4QkFBOEIsRUFBRSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQzlFLE1BQU0sR0FBRyxHQUFHLElBQUksb0JBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFekMsTUFBTSxFQUFFLEdBQUcsSUFBSSxrQkFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBRWxELEVBQUUsQ0FBQyxXQUFXLENBQUM7WUFDYixnQkFBZ0IsRUFBRSwyQkFBcUIsQ0FBQyxJQUFJO1lBQzVDLFlBQVksRUFBRSxJQUFJO1lBQ2xCLGdCQUFnQixFQUFFLDJCQUFxQixDQUFDLElBQUk7WUFDNUMsWUFBWSxFQUFFLElBQUk7U0FDbkIsQ0FBQyxDQUFDO1FBRUgsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxxQkFBWSxDQUFDLHlDQUF5QyxFQUFFO1lBQ3ZFLFNBQVMsRUFBRSxDQUFDO29CQUNWLFlBQVksRUFBRSxNQUFNO29CQUNwQixnQkFBZ0IsRUFBRSxNQUFNO29CQUN4QixnQkFBZ0IsRUFBRSxNQUFNO29CQUN4QixRQUFRLEVBQUUsTUFBTTtpQkFDakIsQ0FBQztTQUNILENBQUMsQ0FBQyxDQUFDO1FBRUosSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVELG9CQUFvQixDQUFDLElBQVU7UUFDN0IsUUFBUTtRQUNSLE1BQU0sS0FBSyxHQUFHLElBQUksV0FBSyxFQUFFLENBQUM7UUFDMUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxvQkFBVSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV6QyxPQUFPO1FBQ1AsSUFBSSxrQkFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUU7WUFDNUIsR0FBRztZQUNILFdBQVcsRUFBRTtnQkFDWCxRQUFRLEVBQUUsRUFBRTtnQkFDWixJQUFJLEVBQUUsT0FBTztnQkFDYixRQUFRLEVBQUUsMkJBQXFCLENBQUMsS0FBSztnQkFDckMsSUFBSSxFQUFFLEdBQUc7YUFDVjtTQUNGLENBQUMsQ0FBQztRQUVILE9BQU87UUFDUCxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLHFCQUFZLENBQUMseUNBQXlDLEVBQUU7WUFDdkUsV0FBVyxFQUFFO2dCQUNYLGdCQUFnQixFQUFFLEdBQUc7Z0JBQ3JCLFFBQVEsRUFBRSxJQUFJO2dCQUNkLE1BQU0sRUFBRSxnQkFBZ0I7Z0JBQ3hCLE9BQU8sRUFBRSxHQUFHO2dCQUNaLGtCQUFrQixFQUFFLEdBQUc7YUFDeEI7U0FDRixDQUFDLENBQUMsQ0FBQztRQUVKLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRCwwQ0FBMEMsQ0FBQyxJQUFVO1FBQ25ELFFBQVE7UUFDUixNQUFNLEtBQUssR0FBRyxJQUFJLFdBQUssRUFBRSxDQUFDO1FBQzFCLE1BQU0sR0FBRyxHQUFHLElBQUksb0JBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDekMsTUFBTSxHQUFHLEdBQUcsSUFBSSxrQkFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUU7WUFDeEMsR0FBRztZQUNILFdBQVcsRUFBRTtnQkFDWCxRQUFRLEVBQUUsRUFBRTtnQkFDWixJQUFJLEVBQUUsT0FBTztnQkFDYixRQUFRLEVBQUUsMkJBQXFCLENBQUMsS0FBSztnQkFDckMsSUFBSSxFQUFFLEdBQUc7YUFDVjtTQUNGLENBQUMsQ0FBQztRQUVILE9BQU87UUFDUCxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUMxRCxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksVUFBVSxFQUFFLENBQUMsQ0FBQztRQUVoQyx5RUFBeUU7UUFDekUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxxQkFBWSxDQUFDLHlCQUF5QixFQUFFO1lBQ3ZELG1CQUFtQixFQUFFO2dCQUNuQjtvQkFDRSxXQUFXLEVBQUUsdUJBQXVCO29CQUNwQyxNQUFNLEVBQUUscUJBQXFCO29CQUM3QixRQUFRLEVBQUUsSUFBSTtvQkFDZCxVQUFVLEVBQUUsS0FBSztvQkFDakIsTUFBTSxFQUFFLElBQUk7aUJBQ2I7YUFDRjtTQUNGLENBQUMsQ0FBQyxDQUFDO1FBRUosSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleHBlY3QsIGhhdmVSZXNvdXJjZSB9IGZyb20gJ0Bhd3MtY2RrL2Fzc2VydCc7XG5pbXBvcnQgeyBDaWRySVB2NCwgQ29ubmVjdGlvbnMsIFZwY05ldHdvcmsgfSBmcm9tICdAYXdzLWNkay9hd3MtZWMyJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGF3cy1jZGsvY2RrJztcbmltcG9ydCB7IFRlc3QgfSBmcm9tICdub2RldW5pdCc7XG5pbXBvcnQgeyBJTG9hZEJhbGFuY2VyVGFyZ2V0LCBMb2FkQmFsYW5jZXIsIExvYWRCYWxhbmNpbmdQcm90b2NvbCB9IGZyb20gJy4uL2xpYic7XG5cbmV4cG9ydCA9IHtcbiAgJ3Rlc3Qgc3BlY2lmeWluZyBub25zdGFuZGFyZCBwb3J0IHdvcmtzJyh0ZXN0OiBUZXN0KSB7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2sodW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgZW52OiB7IGFjY291bnQ6ICcxMjM0JywgcmVnaW9uOiAndGVzdCcgfX0pO1xuICAgIHN0YWNrLm5vZGUuc2V0Q29udGV4dCgnYXZhaWxhYmlsaXR5LXpvbmVzOjEyMzQ6dGVzdCcsIFsndGVzdC0xYScsICd0ZXN0LTFiJ10pO1xuICAgIGNvbnN0IHZwYyA9IG5ldyBWcGNOZXR3b3JrKHN0YWNrLCAnVkNQJyk7XG5cbiAgICBjb25zdCBsYiA9IG5ldyBMb2FkQmFsYW5jZXIoc3RhY2ssICdMQicsIHsgdnBjIH0pO1xuXG4gICAgbGIuYWRkTGlzdGVuZXIoe1xuICAgICAgZXh0ZXJuYWxQcm90b2NvbDogTG9hZEJhbGFuY2luZ1Byb3RvY29sLkh0dHAsXG4gICAgICBleHRlcm5hbFBvcnQ6IDgwODAsXG4gICAgICBpbnRlcm5hbFByb3RvY29sOiBMb2FkQmFsYW5jaW5nUHJvdG9jb2wuSHR0cCxcbiAgICAgIGludGVybmFsUG9ydDogODA4MCxcbiAgICB9KTtcblxuICAgIGV4cGVjdChzdGFjaykudG8oaGF2ZVJlc291cmNlKFwiQVdTOjpFbGFzdGljTG9hZEJhbGFuY2luZzo6TG9hZEJhbGFuY2VyXCIsIHtcbiAgICAgIExpc3RlbmVyczogW3tcbiAgICAgICAgSW5zdGFuY2VQb3J0OiBcIjgwODBcIixcbiAgICAgICAgSW5zdGFuY2VQcm90b2NvbDogXCJodHRwXCIsXG4gICAgICAgIExvYWRCYWxhbmNlclBvcnQ6IFwiODA4MFwiLFxuICAgICAgICBQcm90b2NvbDogXCJodHRwXCJcbiAgICAgIH1dXG4gICAgfSkpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2FkZCBhIGhlYWx0aCBjaGVjaycodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBjb25zdCB2cGMgPSBuZXcgVnBjTmV0d29yayhzdGFjaywgJ1ZDUCcpO1xuXG4gICAgLy8gV0hFTlxuICAgIG5ldyBMb2FkQmFsYW5jZXIoc3RhY2ssICdMQicsIHtcbiAgICAgIHZwYyxcbiAgICAgIGhlYWx0aENoZWNrOiB7XG4gICAgICAgIGludGVydmFsOiA2MCxcbiAgICAgICAgcGF0aDogJy9waW5nJyxcbiAgICAgICAgcHJvdG9jb2w6IExvYWRCYWxhbmNpbmdQcm90b2NvbC5IdHRwcyxcbiAgICAgICAgcG9ydDogNDQzLFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVEhFTlxuICAgIGV4cGVjdChzdGFjaykudG8oaGF2ZVJlc291cmNlKFwiQVdTOjpFbGFzdGljTG9hZEJhbGFuY2luZzo6TG9hZEJhbGFuY2VyXCIsIHtcbiAgICAgIEhlYWx0aENoZWNrOiB7XG4gICAgICAgIEhlYWx0aHlUaHJlc2hvbGQ6IFwiMlwiLFxuICAgICAgICBJbnRlcnZhbDogXCI2MFwiLFxuICAgICAgICBUYXJnZXQ6IFwiSFRUUFM6NDQzL3BpbmdcIixcbiAgICAgICAgVGltZW91dDogXCI1XCIsXG4gICAgICAgIFVuaGVhbHRoeVRocmVzaG9sZDogXCI1XCJcbiAgICAgIH0sXG4gICAgfSkpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2FkZCBhIGxpc3RlbmVyIGFuZCBsb2FkIGJhbGFuY2luZyB0YXJnZXQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwY05ldHdvcmsoc3RhY2ssICdWQ1AnKTtcbiAgICBjb25zdCBlbGIgPSBuZXcgTG9hZEJhbGFuY2VyKHN0YWNrLCAnTEInLCB7XG4gICAgICB2cGMsXG4gICAgICBoZWFsdGhDaGVjazoge1xuICAgICAgICBpbnRlcnZhbDogNjAsXG4gICAgICAgIHBhdGg6ICcvcGluZycsXG4gICAgICAgIHByb3RvY29sOiBMb2FkQmFsYW5jaW5nUHJvdG9jb2wuSHR0cHMsXG4gICAgICAgIHBvcnQ6IDQ0MyxcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdIRU5cbiAgICBlbGIuYWRkTGlzdGVuZXIoeyBleHRlcm5hbFBvcnQ6IDgwLCBpbnRlcm5hbFBvcnQ6IDgwODAgfSk7XG4gICAgZWxiLmFkZFRhcmdldChuZXcgRmFrZVRhcmdldCgpKTtcblxuICAgIC8vIFRIRU46IGF0IHRoZSB2ZXJ5IGxlYXN0IGl0IGFkZGVkIGEgc2VjdXJpdHkgZ3JvdXAgcnVsZSBmb3IgdGhlIGJhY2tlbmRcbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZSgnQVdTOjpFQzI6OlNlY3VyaXR5R3JvdXAnLCB7XG4gICAgICBTZWN1cml0eUdyb3VwRWdyZXNzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBEZXNjcmlwdGlvbjogJ1BvcnQgODA4MCBMQiB0byBmbGVldCcsXG4gICAgICAgICAgQ2lkcklwOiBcIjY2Ni42NjYuNjY2LjY2Ni82NjZcIixcbiAgICAgICAgICBGcm9tUG9ydDogODA4MCxcbiAgICAgICAgICBJcFByb3RvY29sOiBcInRjcFwiLFxuICAgICAgICAgIFRvUG9ydDogODA4MFxuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0pKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9XG59O1xuXG5jbGFzcyBGYWtlVGFyZ2V0IGltcGxlbWVudHMgSUxvYWRCYWxhbmNlclRhcmdldCB7XG4gIHB1YmxpYyByZWFkb25seSBjb25uZWN0aW9ucyA9IG5ldyBDb25uZWN0aW9ucyh7XG4gICAgc2VjdXJpdHlHcm91cFJ1bGU6IG5ldyBDaWRySVB2NCgnNjY2LjY2Ni42NjYuNjY2LzY2NicpXG4gIH0pO1xuXG4gIHB1YmxpYyBhdHRhY2hUb0NsYXNzaWNMQihfbG9hZEJhbGFuY2VyOiBMb2FkQmFsYW5jZXIpOiB2b2lkIHtcbiAgICAvLyBOb3RoaW5nIHRvIGRvLiBOb3JtYWxseSB3ZSBzZXQgYSBwcm9wZXJ0eSBvbiBvdXJzZWx2ZXMgc29cbiAgICAvLyBvdXIgaW5zdGFuY2VzIGtub3cgdG8gYmluZCB0byB0aGUgTEIgb24gc3RhcnR1cC5cbiAgfVxufVxuIl19